% The ebproof package - Formal proofs in the style of sequent calculus

%% ebproof.sty
%% Copyright 2015 Emmanuel Beffara <manu@beffara.org>

% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.

% This work has the LPPL maintenance status `maintained'.

% The Current Maintainer of this work is Emmanuel Beffara.

% This work consists of the files ebproof.sty and ebproof.tex.

\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage{ebproof}{2015/05/30}{1.2pre}{EB's proof trees}

% The |pgfkeys| package is used for the parameters in proof construction.

\RequirePackage{pgfkeys}

% The |pgfmath| package is used for computations.

\RequirePackage{pgfmath}

%%% Registers and internal parameters

\bool_new:N \l_ebproof_updown_bool

\bool_new:N \l_ebproof_center_bool
\bool_set_true:N \l_ebproof_center_bool

%%% Parameters

\def\ebproofset#1{\pgfqkeys{/ebproof}{#1}}

\ebproofset{

% general shape

center/.is~choice,
center/.default=true,
center/true/.code={\bool_set_true:N \l_ebproof_center_bool},
center/false/.code={\bool_set_false:N \l_ebproof_center_bool},
proof~style/.is~choice,
proof~style/upwards/.code={\bool_set_false:N \l_ebproof_updown_bool},
proof~style/downwards/.code={\bool_set_true:N \l_ebproof_updown_bool},

% spacing

separation/.initial=1.5em,
rule~margin/.initial=.7ex,

% shape of inference lines

rule~thickness/.initial=.4pt,
rule~separation/.initial=2pt,
rule~dash~length/.initial=.2em,
rule~dash~space/.initial=.3em,
rule~code/.initial=,

% templates

template/.initial=$\inserttext$,
left~template/.initial=$\inserttext\mathrel{}$,
right~template/.initial=$\mathrel{}\inserttext$,

% labels

left~label/.initial=,
right~label/.initial=,
left~label~template/.initial=\inserttext,
right~label~template/.initial=\inserttext,
label~separation/.initial=0.5em,
}

% Rule styles

\pgfqkeys{/ebproof/rule~style}{
.is~choice,
.search~also=/ebproof,
simple/.style={/ebproof/rule~code={
  \tex_hrule:D height \pgfkeysvalueof{/ebproof/rule~thickness}\relax
}},

no~rule/.style={/ebproof/rule~code=},

double/.style={/ebproof/rule~code={
  \tex_hrule:D height \pgfkeysvalueof{/ebproof/rule~thickness}
  \tex_kern:D \pgfkeysvalueof{/ebproof/rule~separation}
  \tex_hrule:D height \pgfkeysvalueof{/ebproof/rule~thickness}
}},

dashed/.style={/ebproof/rule~code={
  \hbox_to_wd:nn { \tex_hsize:D } {
    \dim_set:Nn \l_tmpa_dim { \pgfkeysvalueof{/ebproof/rule~dash~space} / 2 }
    \tex_kern:D -\l_tmpa_dim
    \tex_cleaders:D \hbox:n {
      \tex_kern:D \l_tmpa_dim
      \tex_vrule:D 
        height \pgfkeysvalueof{/ebproof/rule~thickness}
        width \pgfkeysvalueof{/ebproof/rule~dash~length}
      \tex_kern:D \l_tmpa_dim
    }\tex_hfill:D
    \tex_kern:D -\l_tmpa_dim
  }
}},

simple % use the 'simple' rule style by default
}


%%% Annotated boxes

% Proof trees are represented as a data structure that consists of a box and a
% set of marks, which are vertical positions in the box (as distances from the
% left edge). Arbitrary marks can be defined, the folowing are used for
% alignment:
% - left :  the left of the conclusion
% - right : the right of the conclusion
% - axis :  the vertical axis of the conclusion

% TeX does not actually provide data structures, so we have to encode things.
% We provide an allocator for "registers" holding boxes with attributes. Such
% a register consists in a box register and a macro for marks, which contains
% successive instances of |\do{name}{value}| where the value is a number
% without units for the value in points.

% Create a new register.

\cs_new:Nn \ebproof_new:N {
  \box_new:N #1
  \ebproof_clear:N #1
}

% Set the value of a mark. The third argument is a value, parsed by pgfmath.

\cs_new:Nn \ebproof_setmark:Nnn {
  \group_begin:
  \pgfmathparse{#3}
  \def\name{#2}
  \def\ebproof@temp{}
  \def\do##1##2{
    \def\key{##1}
    \ifx\key\name\else
      \expandafter\def\expandafter\ebproof@temp\expandafter{
        \ebproof@temp\do{##1}{##2}}
    \fi
  }\csname ebproof@marks@\the#1\endcsname
  \def\do{\noexpand\do}
  \expandafter\edef\csname ebproof@marks@\the#1\endcsname
    {\ebproof@temp\do{#2}{\pgfmathresult}}
  \expandafter\pgfmathsmuggle\csname ebproof@marks@\the#1\endcsname
  \endgroup
}

% Get the value of a mark, in a pgfmath expression.

\pgfmathdeclarefunction{ebproofmark}{2}{
  \group_begin:
  \def\name{#2}
  \def\check{
    \def\ebproof@temp{0pt}
    \PackageError{ebproof}{unknown~mark~`#2'}{}}
  \def\do##1##2{
    \def\key{##1}
    \ifx\key\name
      \def\ebproof@temp{##2pt}
      \def\do####1####2{}
      \let\check\relax
    \fi
  }\csname ebproof@marks@\the#1\endcsname
  \check
  \pgfmathreturn\ebproof@temp
  \endgroup
}

% Clear a tree register.

\cs_new:Nn \ebproof_clear:N {
  \box_clear:N #1
  \expandafter\def\csname ebproof@marks@\the#1\endcsname{}
}

% Make a box with the axis in the middle.

\cs_new:Nn \ebproof_set_simple:Nn {
  \hbox_set:Nn #1 { #2 }
  \ebproof_setmark:Nnn #1 { left } { 0pt }
  \ebproof_setmark:Nnn #1 { axis } { \wd#1/2 }
  \ebproof_setmark:Nnn #1 { right } { \wd#1 }
}

% Push a box made of two halves, with the axis between the halves.

\cs_new:Nn \ebproof_set_split:Nnn {
  \ebproof_setmark:Nnn #1 { left } { 0pt }
  \hbox_set:Nn #1 { #2 }
  \ebproof_setmark:Nnn #1 { axis } { \wd#1 }
  \hbox_set:Nn #1 { \hbox_unpack:N #1 #3 }
  \ebproof_setmark:Nnn #1 { right } { \wd#1 }
}

% Shift the marks by a specified amount, without modifying the box.

\cs_new:Nn \ebproof_shift_x:Nn {
  \ebproof_setmark:Nnn #1 { left } { ebproofmark("#1","left")+#2 }
  \ebproof_setmark:Nnn #1 { right } { ebproofmark("#1","right")+#2 }
  \ebproof_setmark:Nnn #1 { axis } { ebproofmark("#1","axis")+#2 }
}

% Extend a box on the right by a given length.

\cs_new:Nn \ebproof_extend_right:Nn {
  \hbox_set:Nn #1 {
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
    \skip_horizontal:n { #2 }
  }
}

% Append the contents of the second tree to the first one on the right, with
% matching baselines. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_right:NN {
  \hbox_set:Nn #1 {
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
    \if_hbox:N #2 \hbox_unpack:N #2 \else: \box_use:N #2 \fi:
  }
}

% Append the contents of the second tree to the first one on the left, with
% matching baselines. The marks of the first tree are shifted accordingly.

\cs_new:Nn \ebproof_append_left:NN {
  \ebproof_shift_x:Nn #1{\wd#2}
  \hbox_set:Nn #1 {
    \if_hbox:N #2 \hbox_unpack:N #2 \else: \box_use:N #2 \fi:
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
  }
}

% Append the contents of the second tree above the first one, with matching
% axes. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_above:NN {
  \pgfmathsetlength\l_tmpa_dim{ebproofmark("#2","axis")-ebproofmark("#1","axis")}
  \dim_compare:nNnTF \l_tmpa_dim < { 0pt } {
    \vbox_set:Nn #1 {
      \box_move_left:nn { \l_tmpa_dim } { \box_use:N #2 }
      \tex_hrule:D  height 0pt
      \if_vbox:N #1 \vbox_unpack:N #1 \else: \box_use:N #1 \fi:
    }
  } {
    \vbox_set:Nn #1 {
      \if_vbox:N #2 \vbox_unpack:N #2 \else: \box_use:N #2 \fi:
      \tex_hrule:D  height 0pt
      \box_move_right:nn { \l_tmpa_dim } { \box_use:N #1 }
    }
    \ebproof_shift_x:Nn #1 { \l_tmpa_dim }
  }
}

% Append the contents of the second tree below the first one, with matching
% axes. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_below:NN {
  \pgfmathsetlength\l_tmpa_dim{ebproofmark("#2","axis")-ebproofmark("#1","axis")}
  \dim_compare:nNnTF { \l_tmpa_dim } < { 0pt } {
    \vbox_set_top:Nn #1 {
      \if_vbox:N #1 \vbox_unpack:N #1 \else: \box_use:N #1 \fi:
      \tex_hrule:D  height 0pt
      \box_move_left:nn { \l_tmpa_dim } { \box_use:N #2 }
    }
  } {
    \vbox_set_top:Nn #1 {
      \box_move_right:nn { \l_tmpa_dim } { \box_use:N #1 }
      \tex_hrule:D  height 0pt
      \if_vbox:N #2 \vbox_unpack:N #2 \else: \box_use:N #2 \fi:
    }
    \ebproof_shift_x:Nn #1 { \l_tmpa_dim }
  }
}


%%% The stack

% Logically, box structures are stored on a stack. However, TeX does not
% provide data structures for that and the grouping mechanism is not flexible
% enough, so we encode them using what we actually have. A stack for boxes is
% implemented using a global hbox |\g_ebproof_stack_box| that contains all the
% boxes successively, and the |\lastbox| primitive allows us to pop elements
% from there. A macro | \g_ebproof_stack_seq | is used to store the dimensions
% textually: the empty stack is an empty macro, and a non-empty stack is
% represented as |{marks}{tail}|. We maintain a counter |\g_ebproof_level_int| with
% the number of elements on the stack, for consistency checks.

\int_new:N \g_ebproof_level_int
\box_new:N \g_ebproof_stack_box
\seq_new:N \g_ebproof_stack_seq

% Clear the stack.

\cs_new:Nn \ebproof_clear_stack: {
  \int_gset:Nn \g_ebproof_level_int { 0 }
  \hbox_gset:Nn \g_ebproof_stack_box { }
  \seq_gclear:N \g_ebproof_stack_seq
}

% Push the contents of a register on the stack.

\cs_new:Nn \ebproof_push:N {
  \int_gincr:N \g_ebproof_level_int
  \hbox_gset:Nn \g_ebproof_stack_box
    { \hbox_unpack:N \g_ebproof_stack_box \box_use:N #1 }
  \seq_gput_left:Nv \g_ebproof_stack_seq { ebproof@marks@\the#1 }
}

% Pop the value from the top of the stack into a register.

\cs_new:Nn \ebproof_pop:N {
  \int_compare:nNnTF { \g_ebproof_level_int } > { 0 } {
    \int_gdecr:N \g_ebproof_level_int
    \hbox_gset:Nn \g_ebproof_stack_box {
      \hbox_unpack:N \g_ebproof_stack_box
      \box_gset_to_last:N \g_tmpa_box
    }
    \box_set_eq_clear:NN #1 \g_tmpa_box
    \seq_gpop_left:NN \g_ebproof_stack_seq \l_tmpa_tl
    \tl_set_eq:cN { ebproof@marks@\the#1 } \l_tmpa_tl
  } {
    \PackageError{ebproof}{Missing~premiss~in~a~proof~tree}{}
    \ebproof_clear:N #1
  }
}


%%% Stack-based operations

\ebproof_new:N \l_ebproof_a_box
\ebproof_new:N \l_ebproof_b_box
\ebproof_new:N \l_ebproof_c_box
\ebproof_new:N \l_ebproof_d_box

% Join horizontally the two elements at the top of the stack. Use the left
% mark of the left tree, the right mark of the right tree and set the axis in
% the middle of these marks.

\cs_new:Nn \ebproof_joinh: {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \ebproof_pop:N \l_ebproof_b_box
  \ebproof_extend_right:Nn \l_ebproof_b_box
    { \pgfkeysvalueof { /ebproof/separation } }
  \ebproof_setmark:Nnn \l_ebproof_a_box { right }
    { ebproofmark("\l_ebproof_a_box","right")+\wd\l_ebproof_b_box }
  \ebproof_append_right:NN \l_ebproof_b_box \l_ebproof_a_box
  \ebproof_setmark:Nnn \l_ebproof_b_box { right }
    { ebproofmark("\l_ebproof_a_box","right") }
  \ebproof_setmark:Nnn \l_ebproof_b_box { axis }
    { ( ebproofmark("\l_ebproof_b_box","left")
      + ebproofmark("\l_ebproof_b_box","right") )/2 }
  \ebproof_push:N \l_ebproof_b_box
  \group_end:
}

% An $n$-ary version of the horizontal join.

\cs_new:Nn \ebproof_join_horizontal:n {
  \int_case:nnF { #1 } {
  { 0 } {
    \group_begin:
    \ebproof_clear:N \l_ebproof_a_box
    \hbox_set:Nn \l_ebproof_a_box {}
    \ebproof_setmark:Nnn \l_ebproof_a_box { left } { 0 }
    \ebproof_setmark:Nnn \l_ebproof_a_box { right } { 0 }
    \ebproof_setmark:Nnn \l_ebproof_a_box { axis } { 0 }
    \ebproof_push:N \l_ebproof_a_box
    \group_end:
  }
  { 1 } { }
  } {
    \prg_replicate:nn { #1 - 1 } { \ebproof_joinh: }
  }
}

% Join vertically the two elements at the top of the stack, with a horizontal
% rule of the appropriate size.

\cs_new:Nn \ebproof_join_vertical: {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \ebproof_pop:N \l_ebproof_b_box
  \ebproof_clear:N \l_ebproof_c_box
 
  % Compute the width and axis of the rule in C's parameters
 
  \ebproof_setmark:Nnn \l_ebproof_c_box { left } { 0 }
  \ebproof_setmark:Nnn \l_ebproof_c_box { axis } { max(
    ebproofmark("\l_ebproof_a_box","axis") - ebproofmark("\l_ebproof_a_box","left"),
    ebproofmark("\l_ebproof_b_box","axis") - ebproofmark("\l_ebproof_b_box","left")) }
  \ebproof_setmark:Nnn \l_ebproof_c_box { right } {
    ebproofmark("\l_ebproof_c_box","axis") + max(
      ebproofmark("\l_ebproof_a_box","right") - ebproofmark("\l_ebproof_a_box","axis"),
      ebproofmark("\l_ebproof_b_box","right") - ebproofmark("\l_ebproof_b_box","axis")) }
 
  % Render the rule in C's box
 
  \vbox_set:Nn \l_ebproof_c_box {
    \pgfmathsetlength\hsize{ebproofmark("\l_ebproof_c_box","right")}
    \tex_hrule:D width \tex_hsize:D height 0pt
    \tex_kern:D \pgfkeysvalueof{/ebproof/rule~margin}
    \pgfkeysgetvalue{/ebproof/rule~code}{\@rulecode}
    \ifx\@rulecode\@empty\else
      \@rulecode
      \unskip% so that only one margin is inserted if no rule is drawn
      \kern\pgfkeysvalueof{/ebproof/rule~margin}
    \fi
    \tex_hrule:D  width \hsize height 0pt
  }
 
  % Compute the vertical shift of the rule for centering using \vcenter, save
  % the height of the rule box.
 
  \hbox_set:Nn \l_tmpa_box { $\tex_vcenter:D { \box_use:N \l_ebproof_c_box }$ }
  \dim_set:Nn \l_tmpa_dim { \box_ht:N \l_tmpa_box - \box_ht:N \l_ebproof_c_box }
  \dim_set:Nn \l_tmpb_dim { \box_ht:N \l_tmpa_box }
 
  % Render the labels and append them.
 
  \hbox_set:Nn \l_tmpa_box {
    \def\inserttext{\pgfkeysvalueof{/ebproof/left~label}}
    \pgfkeysvalueof{/ebproof/left~label~template}
  }
  \dim_compare:nNnT { \box_wd:N \l_tmpa_box } > { 0pt } {
    \ebproof_clear:N \l_ebproof_d_box
    \hbox_set:Nn \l_ebproof_d_box {
      \lower\l_tmpa_dim\box\l_tmpa_box
      \kern\pgfkeysvalueof{/ebproof/label~separation}
    }
    \box_set_ht:Nn \l_ebproof_d_box { 0pt }
    \box_set_dp:Nn \l_ebproof_d_box { 0pt }
    \ebproof_append_left:NN \l_ebproof_c_box \l_ebproof_d_box
  }

  \hbox_set:Nn \l_tmpa_box {
    \def\inserttext{\pgfkeysvalueof{/ebproof/right~label}}
    \pgfkeysvalueof{/ebproof/right~label~template}
  }
  \dim_compare:nNnT { \box_wd:N \l_tmpa_box } > { 0pt } {
    \ebproof_clear:N \l_ebproof_d_box
    \hbox_set:Nn \l_ebproof_d_box {
      \tex_kern:D \pgfkeysvalueof{/ebproof/label~separation}
      \box_move_down:nn { \l_tmpa_dim } { \box_use:N \l_tmpa_box }
    }
    \box_set_ht:Nn \l_ebproof_d_box { 0pt }
    \box_set_dp:Nn \l_ebproof_d_box { 0pt }
    \ebproof_append_right:NN \l_ebproof_c_box \l_ebproof_d_box
  }
 
  % Assemble the three parts.
 
  \bool_if:NTF \l_ebproof_updown_bool {
    \ebproof_append_below:NN \l_ebproof_a_box \l_ebproof_c_box
    \ebproof_append_below:NN \l_ebproof_a_box \l_ebproof_b_box
  } {
    \ebproof_append_above:NN \l_ebproof_a_box \l_ebproof_c_box
    \ebproof_append_above:NN \l_ebproof_a_box \l_ebproof_b_box
  }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

%%% Modifying boxes

% Alter a proof with a command that does not affect the size. Typically useful
% with |\color| commands.

\cs_new:Nn \ebproof_alter:n {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \hbox_set:Nn \l_ebproof_a_box {{ #1 \box_use:N \l_ebproof_a_box }}
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

% Insert |\left| and |\right| delimiters without changing the alignment

\cs_new:Nn \ebproof_delims:nn {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \hbox_set:Nn \l_tmpa_box { $ \tex_vcenter:D { \box_use:N \l_ebproof_a_box } $ }
  \dim_set:Nn \l_tmpa_dim { \box_ht:N \l_tmpa_box - \box_ht:N \l_ebproof_a_box }
  \hbox_set:Nn \l_ebproof_a_box { $ #1
    \tex_vrule:D  height \ht\l_tmpa_box depth \dp\l_tmpa_box width 0pt\right.$}
  \ebproof_shift_x:Nn \l_ebproof_a_box { \wd \l_ebproof_a_box }
  \hbox_set:Nn \l_ebproof_a_box
    { \hbox_unpack:N \l_ebproof_a_box $ \left. \box_use:N \l_tmpa_box #2 $ }
  \hbox_set:Nn \l_ebproof_a_box
    { \box_move_down:nn { \l_tmpa_dim } { \box_use:N \l_ebproof_a_box } }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}


%%% High-level commands

% Push a box with default formatting, using explicit alignment if the code
% contains a |&| character

\cs_new:Npn \ebproof_hypo_parse:w #1&#2&#3\ebproof_hypo_stop: {
  \group_begin:
  \tl_if_empty:nTF { #3 } {
    \ebproof_set_simple:Nn \l_ebproof_a_box
      {\def\inserttext{#1}\pgfkeysvalueof{/ebproof/template}}
  } {
    \ebproof_set_split:Nnn \l_ebproof_a_box
      {\def\inserttext{#1}\pgfkeysvalueof{/ebproof/left~template}}
      {\def\inserttext{#2}\pgfkeysvalueof{/ebproof/right~template}}
  }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

\newcommand\ebproof@hypo[2][]{
  {\ebproofset{#1} \ebproof_hypo_parse:w #2&& \ebproof_hypo_stop: }}

% Build a n-ary rule

\def\ebproof@infer{
  \@ifnextchar[{\ebproof@infer@}{\ebproof@infer@[]}}
\def\ebproof@infer@[#1]#2{
  \@ifnextchar[
    {\ebproof@infer@with@label{#1}{#2}}
    {\ebproof@infer@@{#1}{#2}}}
\def\ebproof@infer@with@label#1#2[#3]{
  \ebproof@infer@@{#1,right~label={#3}}{#2}}
\def\ebproof@infer@@#1#2#3{{
  \pgfqkeys{/ebproof/rule~style}{.search~also=/ebproof,#1}
  \ebproof_join_horizontal:n {#2}
  \ebproof@hypo{#3}
  \ebproof_join_vertical: }}

% Ellipsis with vertical dots

\cs_new:Nn \ebproof_ellipsis:nn {
  \group_begin:
  \ebproofset{rule~code=}
  \ebproof_set_split:Nnn \l_ebproof_a_box { } {
    \vbox_set:Nn \l_tmpa_box {
      \tex_kern:D 1.2ex
      \hbox:n { \ignorespaces #1 }
      \tex_hrule:D height 0pt
      \tex_kern:D 1.2ex
    }
    \vbox_to_ht:nn { \box_ht:N \l_tmpa_box } {
      \tex_xleaders:D \vbox_to_ht:nn { .8ex }
        { \tex_vss:D \hbox:n { . } \tex_vss:D }
      \tex_vfill:D
    }
    \hbox_overlap_right:n { ~ \box_use:N \l_tmpa_box }
  }
  \ebproof_push:N \l_ebproof_a_box
  \ebproof_join_vertical: 
  \ebproof@hypo{#2}
  \ebproof_join_vertical:
  \group_end:
}

%%% Environment interface

\ebproof_clear_stack:

\tl_new:N \l_ebproof_start_level_tl

\cs_new:Nn \ebproof_begin: {
  \tl_set:Nx \l_ebproof_start_level_tl { \int_use:N \g_ebproof_level_int }
  \vbox_set:Nw \l_tmpa_box
  \cs_set_eq:NN \Hypo \ebproof@hypo
  \cs_set_eq:NN \Infer \ebproof@infer
  \cs_set_eq:NN \Ellipsis \ebproof_ellipsis:nn
  \cs_set_eq:NN \Alter \ebproof_alter:n
  \cs_set_eq:NN \Delims \ebproof_delims:nn
}

\cs_new:Nn \ebproof_end: {
  \vbox_set_end:
  \ebproof_pop:N \l_ebproof_a_box
  \int_compare:nNnF { \g_ebproof_level_int } = { \tl_use:N \l_ebproof_start_level_tl } {
    \PackageError{ebproof}{Malformed proof tree}{
      Some hypotheses were declared but not used in this tree.}
  }
  \bool_if:NTF \l_ebproof_center_bool {
    \hbox:n { $ \tex_vcenter:D { \box_use:N \l_ebproof_a_box } $ }
  } {
    \box_use:N \l_ebproof_a_box
  }
}

\newenvironment{prooftree}[1][]{
  \pgfqkeys{/ebproof/proof~style}{.search~also=/ebproof,#1}
  \hbox_unpack:N \c_empty_box
  \ebproof_begin: 
} {
  \ebproof_end:
}

\newenvironment{prooftree*}[1][]{
  \[
  \pgfqkeys{/ebproof/proof~style}{.search~also=/ebproof,#1}
  \hbox_unpack:N \c_empty_box
  \ebproof_begin: 
}{
  \ebproof_end: 
  \]
  \tex_ignorespaces:D
}
