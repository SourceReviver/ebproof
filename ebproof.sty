% The ebproof package - Formal proofs in the style of sequent calculus

%% ebproof.sty
%% Copyright 2015 Emmanuel Beffara <manu@beffara.org>

% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.

% This work has the LPPL maintenance status `maintained'.

% The Current Maintainer of this work is Emmanuel Beffara.

% This work consists of the files ebproof.sty and ebproof.tex.

\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\RequirePackage{xparse}
\ProvidesExplPackage{ebproof}{2015/05/30}{1.2pre}{EB's proof trees}


%%% Parameters

%% Declaration of the parameters

\keys_define:nn { ebproof } {

% general shape

center .bool_set:N = \l_ebproof_center_bool,

proof~style .choice: ,
proof~style / upwards .code:n = \bool_set_false:N \l_ebproof_updown_bool,
proof~style / downwards .code:n = \bool_set_true:N \l_ebproof_updown_bool,

% spacing

separation .dim_set:N = \l_ebproof_separation_dim,
rule~margin .dim_set:N = \l_ebproof_rule_margin_dim,

% shape of inference lines

rule~thickness .dim_set:N = \l_ebproof_rule_thickness_dim,
rule~separation .dim_set:N = \l_ebproof_rule_separation_dim,
rule~dash~length .dim_set:N = \l_ebproof_rule_dash_length_dim,
rule~dash~space .dim_set:N = \l_ebproof_rule_dash_space_dim,
rule~code .tl_set:N = \l_ebproof_rule_code_tl,

rule~style .choice:,

rule~style / simple .meta:nn = { ebproof } {
  rule~code = { \tex_hrule:D height \l_ebproof_rule_thickness_dim }
},

rule~style / no~rule .meta:nn = { ebproof } {
  rule~code =
},

rule~style / double .meta:nn = { ebproof } {
  rule~code = {
    \tex_hrule:D height \l_ebproof_rule_thickness_dim
    \tex_kern:D \l_ebproof_rule_separation_dim
    \tex_hrule:D height \l_ebproof_rule_thickness_dim
  }
},

rule~style / dashed .meta:nn = { ebproof } {
  rule~code = {
    \hbox_to_wd:nn { \tex_hsize:D } {
      \dim_set:Nn \l_tmpa_dim { \l_ebproof_rule_dash_space_dim / 2 }
      \tex_kern:D -\l_tmpa_dim
      \tex_cleaders:D \hbox:n {
        \tex_kern:D \l_tmpa_dim
        \tex_vrule:D 
          height \l_ebproof_rule_thickness_dim
          width \l_ebproof_rule_dash_length_dim
        \tex_kern:D \l_tmpa_dim
      }\tex_hfill:D
      \tex_kern:D -\l_tmpa_dim
    }
  }
},

% templates

template .tl_set:N = \l_ebproof_template_tl,
left~template .tl_set:N = \l_ebproof_left_template_tl,
right~template .tl_set:N = \l_ebproof_right_template_tl,

% labels

left~label .tl_set:N = \l_ebproof_left_label_tl,
right~label .tl_set:N = \l_ebproof_right_label_tl,
left~label~template .tl_set:N = \l_ebproof_left_label_template_tl,
right~label~template .tl_set:N = \l_ebproof_right_label_template_tl,
label~separation .dim_set:N = \l_ebproof_label_separation_dim,

}

%% Default values

\keys_set:nn { ebproof } {
  center = true,
  proof~style = upwards,
  separation = 1.5em,
  rule~margin = .7ex,
  rule~thickness = .4pt,
  rule~separation = 2pt,
  rule~dash~length = .2em,
  rule~dash~space = .3em,
  rule~style = simple,
  template = $\inserttext$,
  left~template = $\inserttext\mathrel{}$,
  right~template = $\mathrel{}\inserttext$,
  left~label = ,
  right~label = ,
  left~label~template = \inserttext,
  right~label~template = \inserttext,
  label~separation = 0.5em,
}


%%% Annotated boxes

% Proof trees are represented as a data structure that consists of a box and a
% set of marks, which are vertical positions in the box (as distances from the
% left edge). Arbitrary marks can be defined, the folowing are used for
% alignment:
% - left :  the left of the conclusion
% - right : the right of the conclusion
% - axis :  the vertical axis of the conclusion

% TeX does not actually provide data structures, so we have to encode things.
% We provide an allocator for "registers" holding boxes with attributes. Such
% a register consists in a box register and a property list for marks, which
% maps mark names to values as explicit dimensions with units.

% Create a new register.

\cs_new:Nn \ebproof_new:N {
  \box_new:N #1
  \prop_new:c { l_ebproof_marks_ \__int_value:w #1 _prop }
}

% Set the value of a mark. The third argument is a dimension expression.

\dim_new:N \l_ebproof_transit_dim

\cs_new:Nn \ebproof_setmark:Nnn {
  \dim_set:Nn \l_ebproof_transit_dim { #3 }
  \prop_put:cnV { l_ebproof_marks_ \__int_value:w #1 _prop } { #2 }
    \l_ebproof_transit_dim
}

% Get the value of a mark. This is expandable and can be used in expressions.

\cs_new:Nn \ebproof_mark:Nn {
  \prop_item:cn { l_ebproof_marks_ \__int_value:w #1 _prop } { #2 }
}

% Clear a tree register.

\cs_new:Nn \ebproof_clear:N {
  \box_clear:N #1
  \prop_clear:c { l_ebproof_marks_ \__int_value:w #1 _prop }
}

% Make a box with the axis in the middle.

\cs_new:Nn \ebproof_set_simple:Nn {
  \hbox_set:Nn #1 { #2 }
  \ebproof_setmark:Nnn #1 { left } { 0pt }
  \ebproof_setmark:Nnn #1 { axis } { \box_wd:N #1 / 2 }
  \ebproof_setmark:Nnn #1 { right } { \box_wd:N #1 }
}

% Push a box made of two halves, with the axis between the halves.

\cs_new:Nn \ebproof_set_split:Nnn {
  \ebproof_setmark:Nnn #1 { left } { 0pt }
  \hbox_set:Nn #1 { #2 }
  \ebproof_setmark:Nnn #1 { axis } { \box_wd:N #1 }
  \hbox_set:Nn #1 { \hbox_unpack:N #1 #3 }
  \ebproof_setmark:Nnn #1 { right } { \box_wd:N #1 }
}

% Shift the marks by a specified amount, without modifying the box.

\cs_new:Nn \ebproof_shift_x:Nn {
  \ebproof_setmark:Nnn #1 { left } { \ebproof_mark:Nn#1{left}+#2 }
  \ebproof_setmark:Nnn #1 { right } { \ebproof_mark:Nn#1{right}+#2 }
  \ebproof_setmark:Nnn #1 { axis } { \ebproof_mark:Nn#1{axis}+#2 }
}

% Extend a box on the right by a given length.

\cs_new:Nn \ebproof_extend_right:Nn {
  \hbox_set:Nn #1 {
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
    \skip_horizontal:n { #2 }
  }
}

% Append the contents of the second tree to the first one on the right, with
% matching baselines. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_right:NN {
  \hbox_set:Nn #1 {
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
    \if_hbox:N #2 \hbox_unpack:N #2 \else: \box_use:N #2 \fi:
  }
}

% Append the contents of the second tree to the first one on the left, with
% matching baselines. The marks of the first tree are shifted accordingly.

\cs_new:Nn \ebproof_append_left:NN {
  \ebproof_shift_x:Nn #1 { \box_wd:N #2 }
  \hbox_set:Nn #1 {
    \if_hbox:N #2 \hbox_unpack:N #2 \else: \box_use:N #2 \fi:
    \if_hbox:N #1 \hbox_unpack:N #1 \else: \box_use:N #1 \fi:
  }
}

% Append the contents of the second tree above the first one, with matching
% axes. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_above:NN {
  \dim_set:Nn \l_tmpa_dim
    { \ebproof_mark:Nn#2{axis} - \ebproof_mark:Nn#1{axis} }
  \dim_compare:nNnTF \l_tmpa_dim < { 0pt } {
    \vbox_set:Nn #1 {
      \box_move_left:nn { \l_tmpa_dim } { \box_use:N #2 }
      \tex_hrule:D  height 0pt
      \if_vbox:N #1 \vbox_unpack:N #1 \else: \box_use:N #1 \fi:
    }
  } {
    \vbox_set:Nn #1 {
      \if_vbox:N #2 \vbox_unpack:N #2 \else: \box_use:N #2 \fi:
      \tex_hrule:D  height 0pt
      \box_move_right:nn { \l_tmpa_dim } { \box_use:N #1 }
    }
    \ebproof_shift_x:Nn #1 { \l_tmpa_dim }
  }
}

% Append the contents of the second tree below the first one, with matching
% axes. The marks of the first tree are preserved.

\cs_new:Nn \ebproof_append_below:NN {
  \dim_set:Nn \l_tmpa_dim
    { \ebproof_mark:Nn#2{axis} - \ebproof_mark:Nn#1{axis} }
  \dim_compare:nNnTF { \l_tmpa_dim } < { 0pt } {
    \vbox_set_top:Nn #1 {
      \if_vbox:N #1 \vbox_unpack:N #1 \else: \box_use:N #1 \fi:
      \tex_hrule:D  height 0pt
      \box_move_left:nn { \l_tmpa_dim } { \box_use:N #2 }
    }
  } {
    \vbox_set_top:Nn #1 {
      \box_move_right:nn { \l_tmpa_dim } { \box_use:N #1 }
      \tex_hrule:D  height 0pt
      \if_vbox:N #2 \vbox_unpack:N #2 \else: \box_use:N #2 \fi:
    }
    \ebproof_shift_x:Nn #1 { \l_tmpa_dim }
  }
}


%%% The stack

% Logically, box structures are stored on a stack. However, TeX does not
% provide data structures for that and the grouping mechanism is not flexible
% enough, so we encode them using what we actually have. A stack for boxes is
% implemented using a global hbox |\g_ebproof_stack_box| that contains all the
% boxes successively. A sequence |\g_ebproof_stack_seq| is used to store the
% dimensions property lists textually. We maintain a counter
% |\g_ebproof_level_int| with the number of elements on the stack, for
% consistency checks.

\int_new:N \g_ebproof_level_int
\box_new:N \g_ebproof_stack_box
\seq_new:N \g_ebproof_stack_seq

% Clear the stack.

\cs_new:Nn \ebproof_clear_stack: {
  \int_gset:Nn \g_ebproof_level_int { 0 }
  \hbox_gset:Nn \g_ebproof_stack_box { }
  \seq_gclear:N \g_ebproof_stack_seq
}

% Push the contents of a register on the stack.

\cs_new:Nn \ebproof_push:N {
  \int_gincr:N \g_ebproof_level_int
  \hbox_gset:Nn \g_ebproof_stack_box
    { \hbox_unpack:N \g_ebproof_stack_box \box_use:N #1 }
  \seq_gput_left:Nv \g_ebproof_stack_seq
    { l_ebproof_marks_ \__int_value:w #1 _prop }
}

% Pop the value from the top of the stack into a register.

\cs_new:Nn \ebproof_pop:N {
  \int_compare:nNnTF { \g_ebproof_level_int } > { 0 } {
    \int_gdecr:N \g_ebproof_level_int
    \hbox_gset:Nn \g_ebproof_stack_box {
      \hbox_unpack:N \g_ebproof_stack_box
      \box_gset_to_last:N \g_tmpa_box
    }
    \box_set_eq_clear:NN #1 \g_tmpa_box
    \seq_gpop_left:NN \g_ebproof_stack_seq \l_tmpa_tl
    \tl_set_eq:cN { l_ebproof_marks_ \__int_value:w #1 _prop } \l_tmpa_tl
  } {
    \PackageError{ebproof}{Missing~premiss~in~a~proof~tree}{}
    \ebproof_clear:N #1
  }
}


%%% Stack-based operations

\ebproof_new:N \l_ebproof_a_box
\ebproof_new:N \l_ebproof_b_box
\ebproof_new:N \l_ebproof_c_box
\ebproof_new:N \l_ebproof_d_box

% Join horizontally the two elements at the top of the stack. Use the left
% mark of the left tree, the right mark of the right tree and set the axis in
% the middle of these marks.

\cs_new:Nn \ebproof_joinh: {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \ebproof_pop:N \l_ebproof_b_box
  \ebproof_extend_right:Nn \l_ebproof_b_box { \l_ebproof_separation_dim }
  \ebproof_setmark:Nnn \l_ebproof_a_box { right }
    { \ebproof_mark:Nn\l_ebproof_a_box{right} + \box_wd:N \l_ebproof_b_box }
  \ebproof_append_right:NN \l_ebproof_b_box \l_ebproof_a_box
  \ebproof_setmark:Nnn \l_ebproof_b_box { right }
    { \ebproof_mark:Nn\l_ebproof_a_box{right} }
  \ebproof_setmark:Nnn \l_ebproof_b_box { axis }
    { ( \ebproof_mark:Nn\l_ebproof_b_box{left}
      + \ebproof_mark:Nn\l_ebproof_b_box{right} )/2 }
  \ebproof_push:N \l_ebproof_b_box
  \group_end:
}

% An $n$-ary version of the horizontal join.

\cs_new:Nn \ebproof_join_horizontal:n {
  \int_case:nnF { #1 } {
  { 0 } {
    \group_begin:
    \ebproof_clear:N \l_ebproof_a_box
    \hbox_set:Nn \l_ebproof_a_box {}
    \ebproof_setmark:Nnn \l_ebproof_a_box { left } { 0pt }
    \ebproof_setmark:Nnn \l_ebproof_a_box { right } { 0pt }
    \ebproof_setmark:Nnn \l_ebproof_a_box { axis } { 0pt }
    \ebproof_push:N \l_ebproof_a_box
    \group_end:
  }
  { 1 } { }
  } {
    \prg_replicate:nn { #1 - 1 } { \ebproof_joinh: }
  }
}

% Join vertically the two elements at the top of the stack, with a horizontal
% rule of the appropriate size.

\cs_new:Nn \ebproof_join_vertical: {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \ebproof_pop:N \l_ebproof_b_box
  \ebproof_clear:N \l_ebproof_c_box
 
  % Compute the width and axis of the rule in C's parameters
 
  \ebproof_setmark:Nnn \l_ebproof_c_box { left } { 0pt }
  \ebproof_setmark:Nnn \l_ebproof_c_box { axis } { \dim_max:nn
    { \ebproof_mark:Nn\l_ebproof_a_box{axis}
      - \ebproof_mark:Nn\l_ebproof_a_box{left} }
    { \ebproof_mark:Nn\l_ebproof_b_box{axis}
      - \ebproof_mark:Nn\l_ebproof_b_box{left} } }
  \ebproof_setmark:Nnn \l_ebproof_c_box { right } {
    \ebproof_mark:Nn\l_ebproof_c_box{axis} + \dim_max:nn
      { \ebproof_mark:Nn\l_ebproof_a_box{right}
        - \ebproof_mark:Nn\l_ebproof_a_box{axis} }
      { \ebproof_mark:Nn\l_ebproof_b_box{right} 
        - \ebproof_mark:Nn\l_ebproof_b_box{axis} } }
 
  % Render the rule in C's box
 
  \vbox_set:Nn \l_ebproof_c_box {
    \dim_set:Nn \tex_hsize:D { \ebproof_mark:Nn\l_ebproof_c_box{right} }
    \tex_hrule:D width \tex_hsize:D height 0pt
    \tex_kern:D \l_ebproof_rule_margin_dim
    \tl_if_empty:NF { \l_ebproof_rule_code_tl } {
      \tl_use:N \l_ebproof_rule_code_tl
      \tex_unskip:D % so that only one margin is inserted if no rule is drawn
      \tex_kern:D \l_ebproof_rule_margin_dim
    }
    \tex_hrule:D  width \tex_hsize:D height 0pt
  }
 
  % Compute the vertical shift of the rule for centering using \vcenter, save
  % the height of the rule box.
 
  \hbox_set:Nn \l_tmpa_box { $\tex_vcenter:D { \box_use:N \l_ebproof_c_box }$ }
  \dim_set:Nn \l_tmpa_dim { \box_ht:N \l_tmpa_box - \box_ht:N \l_ebproof_c_box }
  \dim_set:Nn \l_tmpb_dim { \box_ht:N \l_tmpa_box }
 
  % Render the labels and append them.
 
  \hbox_set:Nn \l_tmpa_box {
    \cs_set_eq:NN \inserttext \l_ebproof_left_label_tl
    \tl_use:N \l_ebproof_left_label_template_tl
  }
  \dim_compare:nNnT { \box_wd:N \l_tmpa_box } > { 0pt } {
    \ebproof_clear:N \l_ebproof_d_box
    \hbox_set:Nn \l_ebproof_d_box {
      \box_move_down:nn { \l_tmpa_dim } { \box_use:N \l_tmpa_box }
      \tex_kern:D \l_ebproof_label_separation_dim
    }
    \box_set_ht:Nn \l_ebproof_d_box { 0pt }
    \box_set_dp:Nn \l_ebproof_d_box { 0pt }
    \ebproof_append_left:NN \l_ebproof_c_box \l_ebproof_d_box
  }

  \hbox_set:Nn \l_tmpa_box {
    \cs_set_eq:NN \inserttext \l_ebproof_right_label_tl
    \tl_use:N \l_ebproof_right_label_template_tl
  }
  \dim_compare:nNnT { \box_wd:N \l_tmpa_box } > { 0pt } {
    \ebproof_clear:N \l_ebproof_d_box
    \hbox_set:Nn \l_ebproof_d_box {
      \tex_kern:D \l_ebproof_label_separation_dim
      \box_move_down:nn { \l_tmpa_dim } { \box_use:N \l_tmpa_box }
    }
    \box_set_ht:Nn \l_ebproof_d_box { 0pt }
    \box_set_dp:Nn \l_ebproof_d_box { 0pt }
    \ebproof_append_right:NN \l_ebproof_c_box \l_ebproof_d_box
  }
 
  % Assemble the three parts.
 
  \bool_if:NTF \l_ebproof_updown_bool {
    \ebproof_append_below:NN \l_ebproof_a_box \l_ebproof_c_box
    \ebproof_append_below:NN \l_ebproof_a_box \l_ebproof_b_box
  } {
    \ebproof_append_above:NN \l_ebproof_a_box \l_ebproof_c_box
    \ebproof_append_above:NN \l_ebproof_a_box \l_ebproof_b_box
  }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

%%% Modifying boxes

% Alter a proof with a command that does not affect the size. Typically useful
% with |\color| commands.

\cs_new:Nn \ebproof_alter:n {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \hbox_set:Nn \l_ebproof_a_box {{ #1 \box_use:N \l_ebproof_a_box }}
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

% Insert |\left| and |\right| delimiters without changing the alignment

\cs_new:Nn \ebproof_delims:nn {
  \group_begin:
  \ebproof_pop:N \l_ebproof_a_box
  \hbox_set:Nn \l_tmpa_box
    { $ \tex_vcenter:D { \box_use:N \l_ebproof_a_box } $ }
  \dim_set:Nn \l_tmpa_dim
    { \box_ht:N \l_tmpa_box - \box_ht:N \l_ebproof_a_box }
  \hbox_set:Nn \l_ebproof_a_box {
    $ #1 \tex_vrule:D
      height \box_ht:N \l_tmpa_box depth \box_dp:N \l_tmpa_box width 0pt
    \tex_right:D . $
  }
  \ebproof_shift_x:Nn \l_ebproof_a_box { \box_wd:N \l_ebproof_a_box }
  \hbox_set:Nn \l_ebproof_a_box {
    \hbox_unpack:N \l_ebproof_a_box
    $ \tex_left:D . \box_use:N \l_tmpa_box #2 $
  }
  \hbox_set:Nn \l_ebproof_a_box
    { \box_move_down:nn { \l_tmpa_dim } { \box_use:N \l_ebproof_a_box } }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}


%%% High-level commands

% Push a box with default formatting, using explicit alignment if the code
% contains a |&| character

\cs_new:Npn \ebproof_statement_parse:w #1&#2&#3\ebproof_statement_stop: {
  \group_begin:
  \tl_if_empty:nTF { #3 } {
    \ebproof_set_simple:Nn \l_ebproof_a_box
      { \cs_set:Npn \inserttext { #1 } \tl_use:N \l_ebproof_template_tl }
  } {
    \ebproof_set_split:Nnn \l_ebproof_a_box
      { \cs_set:Npn \inserttext { #1 } \tl_use:N \l_ebproof_left_template_tl }
      { \cs_set:Npn \inserttext { #2 } \tl_use:N \l_ebproof_right_template_tl }
  }
  \ebproof_push:N \l_ebproof_a_box
  \group_end:
}

\cs_new:Nn \ebproof_push_statement:n {
  \ebproof_statement_parse:w #1&& \ebproof_statement_stop:
}

% Ellipsis with vertical dots

\cs_new:Nn \ebproof_ellipsis:nn {
  \group_begin:
  \tl_clear:N \l_ebproof_rule_code_tl
  \ebproof_set_split:Nnn \l_ebproof_a_box { } {
    \vbox_set:Nn \l_tmpa_box {
      \tex_kern:D 1.2ex
      \hbox:n { \tex_ignorespaces:D #1 }
      \tex_hrule:D height 0pt
      \tex_kern:D 1.2ex
    }
    \vbox_to_ht:nn { \box_ht:N \l_tmpa_box } {
      \tex_xleaders:D \vbox_to_ht:nn { .8ex }
        { \tex_vss:D \hbox:n { . } \tex_vss:D }
      \tex_vfill:D
    }
    \hbox_overlap_right:n { ~ \box_use:N \l_tmpa_box }
  }
  \ebproof_push:N \l_ebproof_a_box
  \ebproof_join_vertical: 
  \ebproof_push_statement:n {#2}
  \ebproof_join_vertical:
  \group_end:
}


%%% Document interface

\NewDocumentCommand \ebproofset { m } {
  \keys_set:nn { ebproof } { #1 }
}

\NewDocumentCommand \ebproofhypo { O{} m } {
  \group_begin:
  \keys_set:nn { ebproof } { #1 }
  \ebproof_push_statement:n { #2 }
  \group_end:
}

\NewDocumentCommand \ebproofinfer { O{} m O{} m } {
  \group_begin:
  \keys_set_known:nnN { ebproof / rule~style } { #1 } \l_tmpa_tl
  \keys_set:nV { ebproof } \l_tmpa_tl
  \tl_set:Nn \l_ebproof_right_label_tl { #3 }
  \ebproof_join_horizontal:n { #2 }
  \ebproof_push_statement:n { #4 }
  \ebproof_join_vertical:
  \group_end:
}

\ebproof_clear_stack:

\tl_new:N \l_ebproof_start_level_tl

\NewDocumentEnvironment { prooftree } { s O{} } {
  \keys_set_known:nnN { ebproof / proof~style } { #2 } \l_tmpa_tl
  \keys_set:nV { ebproof } \l_tmpa_tl
  \tl_set:Nx \l_ebproof_start_level_tl { \int_use:N \g_ebproof_level_int }
  \vbox_set:Nw \l_tmpa_box
  \cs_set_eq:NN \Hypo \ebproofhypo
  \cs_set_eq:NN \Infer \ebproofinfer
  \cs_set_eq:NN \Ellipsis \ebproof_ellipsis:nn
  \cs_set_eq:NN \Alter \ebproof_alter:n
  \cs_set_eq:NN \Delims \ebproof_delims:nn
} {
  \vbox_set_end:
  \ebproof_pop:N \l_ebproof_a_box
  \int_compare:nNnF { \g_ebproof_level_int } = { \tl_use:N \l_ebproof_start_level_tl } {
    \PackageError{ebproof}{Malformed proof tree}{
      Some hypotheses were declared but not used in this tree.}
  }
  \IfBooleanTF { #1 } {
    \[ \box_use:N \l_ebproof_a_box \]
    \tex_ignorespaces:D
  } {
    \hbox_unpack:N \c_empty_box
    \bool_if:NTF \l_ebproof_center_bool {
      \hbox:n { $ \tex_vcenter:D { \box_use:N \l_ebproof_a_box } $ }
    } {
      \box_use:N \l_ebproof_a_box
    }
  }
}

% A trick for the starred version:
\cs_new:cpn { prooftree* } { \prooftree* }
\cs_new:cpn { endprooftree* } { \endprooftree }
