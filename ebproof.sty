% The ebproof package - Formal proofs in the style of sequent calculus

%% ebproof.sty
%% Copyright 2015 Emmanuel Beffara <manu@beffara.org>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Emmanuel Beffara.
%
% This work consists of the files ebproof.sty and ebproof.tex.

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{ebproof}[2015/03/13 v1.1 EB's proof trees]

% The |pgfkeys| package is used for the parameters in proof construction.

\RequirePackage{pgfkeys}

% The |pgfmath| package is used for computations.

\RequirePackage{pgfmath}

%%% Registers and internal parameters

\newif\ifebproof@updown \ebproof@updownfalse
\newif\ifebproof@center \ebproof@centertrue

%%% Parameters

\def\ebproofset#1{\pgfqkeys{/ebproof}{#1}}

\ebproofset{
%
% general shape
%
center/.is if=ebproof@center,
proof style/.is choice,
proof style/upwards/.code={\ebproof@updownfalse},
proof style/downwards/.code={\ebproof@updowntrue},
%
% spacing
%
separation/.initial=1.5em,
rule margin/.initial=.7ex,
%
% shape of inference lines
%
rule thickness/.initial=.4pt,
rule separation/.initial=2pt,
rule dash length/.initial=.2em,
rule dash space/.initial=.3em,
rule code/.initial=,
%
% templates
%
template/.initial=$\inserttext$,
left template/.initial=$\inserttext\mathrel{}$,
right template/.initial=$\mathrel{}\inserttext$,
%
% labels
%
left label/.initial=,
right label/.initial=,
left label template/.initial=\inserttext,
right label template/.initial=\inserttext,
label separation/.initial=0.5em,
}

% Rule styles

\pgfqkeys{/ebproof/rule style}{
.is choice,
.search also=/ebproof,
simple/.style={/ebproof/rule code={%
  \hrule height \pgfkeysvalueof{/ebproof/rule thickness}\relax
  }},
%
no rule/.style={/ebproof/rule code=},
%
double/.style={/ebproof/rule code={%
  \hrule height \pgfkeysvalueof{/ebproof/rule thickness}
  \kern\pgfkeysvalueof{/ebproof/rule separation}%
  \hrule height \pgfkeysvalueof{/ebproof/rule thickness}
  }},
%
dashed/.style={/ebproof/rule code={%
  \hbox to \hsize{%
    \@tempdima=\pgfkeysvalueof{/ebproof/rule dash space}%
    \divide\@tempdima2%
    \kern-\@tempdima%
    \cleaders\hbox{%
      \kern\@tempdima%
      \vrule
        height \pgfkeysvalueof{/ebproof/rule thickness}
        width \pgfkeysvalueof{/ebproof/rule dash length}%
      \kern\@tempdima
    }\hfill
    \kern-\@tempdima
    }%
  }},
%
simple % use the 'simple' rule style by default
}


%%% Annotated boxes

% Proof trees are represented as a data structure that consists of a box and a
% set of marks, which are vertical positions in the box (as distances from the
% left edge). Arbitrary marks can be defined, the folowing are used for
% alignment:
% - left :  the left of the conclusion
% - right : the right of the conclusion
% - axis :  the vertical axis of the conclusion
%
% TeX does not actually provide data structures, so we have to encode things.
% We provide an allocator for "registers" holding boxes with attributes. Such
% a register consists in a box register and a macro for marks, which contains
% successive instances of |\do{name}{value}| where the value is a number
% without units for the value in points.

% Create a new register.

\def\ebproof@new#1{%
  \newbox#1%
  \ebproof@cleartree#1%
}

% Set the value of a mark. The third argument is a value, parsed by pgfmath.

\def\ebproof@setmark#1#2#3{%
  \begingroup
  \pgfmathparse{#3}%
  \def\name{#2}%
  \def\ebproof@temp{}%
  \def\do##1##2{%
    \def\key{##1}%
    \ifx\key\name\else
      \expandafter\def\expandafter\ebproof@temp\expandafter{%
        \ebproof@temp\do{##1}{##2}}%
    \fi
  }\csname ebproof@marks@\the#1\endcsname
  \def\do{\noexpand\do}%
  \expandafter\edef\csname ebproof@marks@\the#1\endcsname
    {\ebproof@temp\do{#2}{\pgfmathresult}}%
  \expandafter\pgfmathsmuggle\csname ebproof@marks@\the#1\endcsname
  \endgroup
}

% Get the value of a mark, in a pgfmath expression.

\pgfmathdeclarefunction{ebproofmark}{2}{%
  \begingroup
  \def\name{#2}%
  \def\check{%
    \def\ebproof@temp{0pt}%
    \PackageError{ebproof}{unknown mark `#2'}{}}%
  \def\do##1##2{%
    \def\key{##1}%
    \ifx\key\name
      \def\ebproof@temp{##2pt}%
      \def\do####1####2{}%
      \let\check\relax
    \fi
  }\csname ebproof@marks@\the#1\endcsname
  \check
  \pgfmathreturn\ebproof@temp
  \endgroup
}

% Clear a tree register.

\def\ebproof@cleartree#1{%
  \setbox#1=\box\voidb@x
  \expandafter\def\csname ebproof@marks@\the#1\endcsname{}%
}

% Make a box with the axis in the middle.

\def\ebproof@setsimple#1#2{%
  \setbox#1=\hbox{#2}%
  \ebproof@setmark#1{left}{0pt}%
  \ebproof@setmark#1{axis}{\wd#1/2}%
  \ebproof@setmark#1{right}{\wd#1}%
}

% Push a box made of two halves, with the axis between the halves.

\def\ebproof@setsplit#1#2#3{%
  \ebproof@setmark#1{left}{0pt}%
  \setbox#1=\hbox{#2}%
  \ebproof@setmark#1{axis}{\wd#1}%
  \setbox#1=\hbox{\unhbox#1#3}%
  \ebproof@setmark#1{right}{\wd#1}%
}

% Shift the marks by a specified amount, without modifying the box.

\def\ebproof@shiftx#1#2{%
  \ebproof@setmark#1{left}{ebproofmark("#1","left")+#2}%
  \ebproof@setmark#1{right}{ebproofmark("#1","right")+#2}%
  \ebproof@setmark#1{axis}{ebproofmark("#1","axis")+#2}%
}

% Extend a box on the right by a given length.

\def\ebproof@extendright#1#2{%
  \setbox#1\hbox{%
    \ifhbox#1\unhbox#1\else\box#1\fi
    \kern#2}}

% Append the contents of the second tree to the first one on the right, with
% matching baselines. The marks of the first tree are preserved.

\def\ebproof@appendright#1#2{%
  \setbox#1\hbox{%
    \ifhbox#1\unhbox#1\else\box#1\fi
    \ifhbox#2\unhcopy#2\else\copy#2\fi}}

% Append the contents of the second tree to the first one on the left, with
% matching baselines. The marks of the first tree are shifted accordingly.

\def\ebproof@appendleft#1#2{%
  \ebproof@shiftx#1{\wd#2}%
  \setbox#1\hbox{%
    \ifhbox#2\unhcopy#2\else\copy#2\fi
    \ifhbox#1\unhbox#1\else\box#1\fi}}

% Append the contents of the second tree above the first one, with matching
% axes. The marks of the first tree are preserved.

\def\ebproof@appendabove#1#2{%
  \pgfmathsetlength\@tempdima{ebproofmark("#2","axis")-ebproofmark("#1","axis")}%
  \ifdim\@tempdima<0pt%
    \setbox#1\vbox{%
      \moveleft\@tempdima\copy#2%
      \hrule height 0pt%
      \ifvbox#1\unvbox#1\else\box#1\fi}%
  \else
    \setbox#1\vbox{%
      \ifvbox#2\unvcopy#2\else\copy#2\fi
      \hrule height 0pt%
      \moveright\@tempdima\box#1}%
    \ebproof@shiftx#1\@tempdima
  \fi
}

% Append the contents of the second tree below the first one, with matching
% axes. The marks of the first tree are preserved.

\def\ebproof@appendbelow#1#2{%
  \pgfmathsetlength\@tempdima{ebproofmark("#2","axis")-ebproofmark("#1","axis")}%
  \ifdim\@tempdima<0pt%
    \setbox#1\vtop{%
      \ifvbox#1\unvbox#1\else\box#1\fi
      \hrule height 0pt%
      \moveleft\@tempdima\copy#2}%
  \else
    \setbox#1\vtop{%
      \moveright\@tempdima\box#1%
      \hrule height 0pt%
      \ifvbox#2\unvcopy#2\else\copy#2\fi}%
    \ebproof@shiftx#1\@tempdima
  \fi
}


%%% The stack

% Logically, box structures are stored on a stack. However, TeX does not
% provide data structures for that and the grouping mechanism is not flexible
% enough, so we encode them using what we actually have. A stack for boxes is
% implemented using a global hbox |\ebproof@box@stack| that contains all the
% boxes successively, and the |\lastbox| primitive allows us to pop elements
% from there. A macro |\ebproof@stack| is used to store the dimensions
% textually: the empty stack is an empty macro, and a non-empty stack is
% represented as |{marks}{tail}|. We maintain a counter |\ebproof@level| with
% the number of elements on the stack, for consistency checks.

\newcount\ebproof@level
\newbox\ebproof@box@stack
\newbox\ebproof@box@temp

% Clear the stack.

\def\ebproof@clearstack{%
  \global\ebproof@level=0%
  \global\setbox\ebproof@box@stack=\box\voidb@x%
  \gdef\ebproof@stack{}}

% Push the contents of a register on the stack.

\def\ebproof@push#1{%
  \global\advance\ebproof@level1\relax
  \global\setbox\ebproof@box@stack=\hbox{%
    \unhbox\ebproof@box@stack\copy#1}%
  \begingroup
  \def\do{\noexpand\do}%
  \xdef\ebproof@stack{%
    {\csname ebproof@marks@\the#1\endcsname}%
    {\ebproof@stack}}%
  \endgroup
}

% Pop the value from the top of the stack into a register.

\def\ebproof@pop#1{%
  \ifnum\ebproof@level>0\relax
    \global\advance\ebproof@level-1\relax
    \global\setbox\ebproof@box@stack=\hbox{%
      \unhbox\ebproof@box@stack
      \global\setbox\ebproof@box@temp=\lastbox}%
    \setbox#1=\box\ebproof@box@temp
    \begingroup\def\pop##1##2{\endgroup
      \expandafter\def\csname ebproof@marks@\the#1\endcsname{##1}%
      \gdef\ebproof@stack{##2}}%
    \expandafter\pop\ebproof@stack
  \else
    \PackageError{ebproof}{%
      Missing premiss in a proof tree}{}%
    \ebproof@cleartree#1%
  \fi
}


%%% Stack-based operations

\ebproof@new\ebproof@A
\ebproof@new\ebproof@B
\ebproof@new\ebproof@C
\ebproof@new\ebproof@D

% Join horizontally the two elements at the top of the stack. Use the left
% mark of the left tree, the right mark of the right tree and set the axis in
% the middle of these marks.

\def\ebproof@joinh{%
  \begingroup
  \ebproof@pop\ebproof@A%
  \ebproof@pop\ebproof@B%
  \ebproof@extendright\ebproof@B{\pgfkeysvalueof{/ebproof/separation}}%
  \ebproof@setmark\ebproof@A{right}{%
    ebproofmark("\ebproof@A","right")+\wd\ebproof@B}
  \ebproof@appendright\ebproof@B\ebproof@A
  \ebproof@setmark\ebproof@B{right}{ebproofmark("\ebproof@A","right")}%
  \ebproof@setmark\ebproof@B{axis}{%
    (ebproofmark("\ebproof@B","left")+ebproofmark("\ebproof@B","right"))/2}%
  \ebproof@push\ebproof@B%
  \endgroup}

% An $n$-ary version of the horizontal join.

\def\ebproof@joinh@multi#1{%
  \begingroup
  \countdef\c=1
  \c=#1\relax%
  \ifnum\c=0
    \ebproof@cleartree\ebproof@A%
    \setbox\ebproof@A=\hbox{}%
    \ebproof@setmark\ebproof@A{left}{0}%
    \ebproof@setmark\ebproof@A{right}{0}%
    \ebproof@setmark\ebproof@A{axis}{0}%
    \ebproof@push\ebproof@A%
  \else
    \ebproof@joinh@loop
  \fi
  \endgroup}
\def\ebproof@joinh@loop{%
  \ifnum\c>1
    \ebproof@joinh
    \advance\c-1
    \expandafter\ebproof@joinh@loop
  \fi}

% Append the last element to the right of the previous one, without changing
% its alignment.

\def\ebproof@joinright{%
  \begingroup
  \ebproof@pop\ebproof@A%
  \ebproof@pop\ebproof@B%
  \ebproof@extendright\ebproof@B{\pgfkeysvalueof{/ebproof/separation}}%
  \ebproof@appendright\ebproof@B\ebproof@A
  \ebproof@push\ebproof@B%
  \endgroup}

% Join vertically the two elements at the top of the stack, with a horizontal
% rule of the appropriate size.

\def\ebproof@joinv{%
  \ebproof@pop\ebproof@A
  \ebproof@pop\ebproof@B
  \ebproof@cleartree\ebproof@C
  %
  % Compute the width and axis of the rule in C's parameters
  %
  \ebproof@setmark\ebproof@C{left}{0}%
  \ebproof@setmark\ebproof@C{axis}{max(%
    ebproofmark("\ebproof@A","axis")-ebproofmark("\ebproof@A","left"),
    ebproofmark("\ebproof@B","axis")-ebproofmark("\ebproof@B","left"))}%
  \ebproof@setmark\ebproof@C{right}{ebproofmark("\ebproof@C","axis")+max(%
    ebproofmark("\ebproof@A","right")-ebproofmark("\ebproof@A","axis"),
    ebproofmark("\ebproof@B","right")-ebproofmark("\ebproof@B","axis"))}%
  %
  % Render the rule in C's box
  %
  \setbox\ebproof@C=\vbox{%
    \pgfmathsetlength\hsize{ebproofmark("\ebproof@C","right")}%
    \hrule width \hsize height 0pt\relax
    \kern\pgfkeysvalueof{/ebproof/rule margin}%
    \pgfkeysgetvalue{/ebproof/rule code}{\@rulecode}%
    \ifx\@rulecode\@empty\else
      \@rulecode
      \unskip% so that only one margin is inserted if no rule is drawn
      \kern\pgfkeysvalueof{/ebproof/rule margin}%
    \fi
    \hrule width \hsize height 0pt%
  }%
  %
  % Compute the vertical shift of the rule for centering using \vcenter, save
  % the height of the rule box.
  %
  \setbox\@tempboxa=\hbox{$\vcenter{\copy\ebproof@C}$}%
  \@tempdima=\ht\@tempboxa
  \advance\@tempdima-\ht\ebproof@C
  \@tempdimb=\ht\@tempboxa
  %
  % Render the labels and append them.
  %
  \setbox\@tempboxa=\hbox{%
    \def\inserttext{\pgfkeysvalueof{/ebproof/left label}}%
    \pgfkeysvalueof{/ebproof/left label template}}%
  \ifdim\wd\@tempboxa>0pt%
    \ebproof@cleartree\ebproof@D
    \setbox\ebproof@D=\hbox{\smash{%
      \lower\@tempdima\box\@tempboxa
      \kern\pgfkeysvalueof{/ebproof/label separation}}}%
    \ebproof@appendleft\ebproof@C\ebproof@D
  \fi
  \setbox\@tempboxa=\hbox{\smash{%
    \def\inserttext{\pgfkeysvalueof{/ebproof/right label}}%
    \pgfkeysvalueof{/ebproof/right label template}}}%
  \ifdim\wd\@tempboxa>0pt%
    \ebproof@cleartree\ebproof@D
    \setbox\ebproof@D=\hbox{%
      \kern\pgfkeysvalueof{/ebproof/label separation}%
      \lower\@tempdima\box\@tempboxa}%
    \ebproof@appendright\ebproof@C\ebproof@D
  \fi
  %
  % Assemble the three parts.
  %
  \ifebproof@updown
    \ebproof@appendbelow\ebproof@A\ebproof@C
    \ebproof@appendbelow\ebproof@A\ebproof@B
  \else
    \ebproof@appendabove\ebproof@A\ebproof@C
    \ebproof@appendabove\ebproof@A\ebproof@B
  \fi
  \ebproof@push\ebproof@A
}

%%% Modifying boxes

% Alter a proof with a command that does not affect the size. Typically useful
% with |\color| commands.

\def\ebproof@alter#1{%
  \begingroup
  \ebproof@pop\ebproof@A%
  \setbox\ebproof@A=\hbox{{#1\box\ebproof@A}}%
  \ebproof@push\ebproof@A%
  \endgroup}

% Insert |\left| and |\right| delimiters without changing the alignment

\def\ebproof@delims#1#2{%
  \begingroup
  \ebproof@pop\ebproof@A%
  \setbox\@tempboxa=\hbox{$\vcenter{\copy\ebproof@A}$}%
  \@tempdima=\ht\@tempboxa
  \advance\@tempdima-\ht\ebproof@A
  \setbox\ebproof@A=\hbox{$#1%
    \vrule height \ht\@tempboxa depth \dp\@tempboxa width 0pt\right.$}%
  \ebproof@shiftx\ebproof@A{\wd\ebproof@A}%
  \setbox\ebproof@A=\hbox{\unhbox\ebproof@A$\left.\box\@tempboxa#2$}%
  \setbox\ebproof@A=\hbox{\raise-\@tempdima\box\ebproof@A}%
  \ebproof@push\ebproof@A%
  \endgroup}


%%% High-level commands

% Push a box with default formatting, using explicit alignment if the code
% contains a |&| character

\def\ebproof@hypo@parse#1&#2&#3\ebproof@hypo@stop{
  {\def\ARG{#3}\ifx\ARG\@empty
      \aftergroup\iftrue\@gobble\fi
      \else\aftergroup\iffalse\@gobble\fi\fi}%
  % The above code has produced \iftrue or \iffalse here.
    \ebproof@setsimple\ebproof@A
      {\def\inserttext{#1}\pgfkeysvalueof{/ebproof/template}}%
  \else
    \ebproof@setsplit\ebproof@A
      {\def\inserttext{#1}\pgfkeysvalueof{/ebproof/left template}}%
      {\def\inserttext{#2}\pgfkeysvalueof{/ebproof/right template}}%
  \fi
  \ebproof@push\ebproof@A
}

\newcommand\ebproof@hypo[2][]{%
  {\ebproofset{#1}\ebproof@hypo@parse#2&&\ebproof@hypo@stop}}

% Build a n-ary rule

\def\ebproof@infer{%
  \@ifnextchar[{\ebproof@infer@}{\ebproof@infer@[]}}
\def\ebproof@infer@[#1]#2{%
  \@ifnextchar[%
    {\ebproof@infer@with@label{#1}{#2}}%
    {\ebproof@infer@@{#1}{#2}}}
\def\ebproof@infer@with@label#1#2[#3]{%
  \ebproof@infer@@{#1,right label={#3}}{#2}}
\def\ebproof@infer@@#1#2#3{{%
  \pgfqkeys{/ebproof/rule style}{.search also=/ebproof,#1}%
  \ebproof@joinh@multi{#2}%
  \ebproof@hypo{#3}%
  \ebproof@joinv}}

% Ellipsis with vertical dots

\def\ebproof@ellipsis#1#2{{%
  \ebproofset{rule code=}%
  \ebproof@setsplit\ebproof@A{}{%
    \setbox0=\vbox{\kern1.2ex\hbox{\ignorespaces#1}\hrule height 0pt\kern1.2ex}%
    \vbox to\ht0{\xleaders\vbox to .8ex{\vss\hbox{.}\vss}\vfill}%
    \rlap{ \box0}}%
  \ebproof@push\ebproof@A
  \ebproof@joinv
  \ebproof@hypo{#2}%
  \ebproof@joinv}}

%%% Environment interface

\ebproof@clearstack

\def\ebproof@begin{%
  \edef\ebproof@start@level{\the\ebproof@level}%
  \setbox1=\vbox\bgroup
  \let\Hypo=\ebproof@hypo
  \let\Infer=\ebproof@infer
  \let\Ellipsis=\ebproof@ellipsis
  \let\Alter=\ebproof@alter
  \let\Delims=\ebproof@delims}
\def\ebproof@end{%
  \egroup
  \ebproof@pop\ebproof@A%
  \ifnum\ebproof@level=\ebproof@start@level\else
    \PackageError{ebproof}{Malformed proof tree}{%
      Some hypotheses were declared but not used in this tree.}%
  \fi
  \ifebproof@center
    \hbox{$\vcenter{\hbox{\box\ebproof@A}}$}%
  \else
    \box\ebproof@A
  \fi
  \global\setbox\ebproof@box@temp=\box1}

\newenvironment{prooftree}[1][]{%
  \pgfqkeys{/ebproof/proof style}{.search also=/ebproof,#1}%
  \leavevmode\ebproof@begin
}{%
  \ebproof@end}

\newenvironment{prooftree*}[1][]{%
  \[%
  \pgfqkeys{/ebproof/proof style}{.search also=/ebproof,#1}%
  \leavevmode\ebproof@begin
}{%
  \ebproof@end
  \]\ignorespaces}
